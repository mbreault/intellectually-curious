# Evolutionary Computation Unplugged: From Turing to Genetic Programming

**Published:** January 09, 2025  
**Duration:** 12m 25s  
**Episode ID:** 17692415

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17692415-evolutionary-computation-unplugged-from-turing-to-genetic-programming)**

## Description

A STEM-friendly deep dive into how evolutionary computation uses randomness and Darwinian principles to solve hard optimization problems. Weâ€™ll trace its originsâ€”from Alan Turingâ€™s early ideas to the three branches (evolution strategies, evolutionary programming, genetic algorithms) and the rise of genetic programmingâ€”then explore real-world applications in engineering and AI, plus how these algorithms model evolution itself.

## Transcript

Welcome back, everyone. We're diving into a really fascinating area today, evolutionary computation. Yeah, using evolution to solve problems. And, you know, our listeners are all STEM enthusiasts. I bet many of you are already familiar with, you know, the more traditional ways of tackling these problems. Right, right. But we're going to explore how evolutionary computation shakes things up a bit. It really does. We'll be using the Wikipedia article on evolutionary computation as our guide today. Excellent resource. So much to unpack there. For sure. Okay, so, you know, one of the things that I always find fascinating about evolutionary computation is this idea that it can get around some of the limits of, like, traditional computing. Absolutely. Like, imagine you're trying to, you know, optimize something really complex. Traditional algorithms can kind of get stuck. Yeah, you hit those local optima. Right. And they never quite reach the best solution. Exactly, yeah. And that's where evolutionary computation steps in, right? It uses randomness and evolution. It does, and that's the beauty of it, I think. It seems counterintuitive. You're using randomness. You are. You're embracing it. You're not relying on these predefined steps or rules. You're really mimicking, you know, Darwinian evolution to kind of navigate these complex spaces. So we're finding solutions that we might have completely missed with a more traditional approach. You got it. It's a powerful idea. Yeah. But, like, how did people even come up with this? It seems like such a leap to go from observing nature to, you know, algorithms. Well, a lot of people don't know this, but Alan Turing actually, you know, back in 1948, he had this vision. He called it genetic search. He was experimenting with, you know, early neural networks, reinforcement learning. Really? Yeah. Amazing how far ahead of his time he was. It's mind-blowing. I mean, you have biology, you have computer science, and they come together in this really powerful way. Right. But Turing was so early. When did this field really take off? I would say the 50s and 60s. That's when it really started to gain momentum. But what's interesting is it didn't, you know, emerge as this one unified field. Okay. There were these three distinct branches, each one kind of tackling things through this evolutionary lens. Oh, interesting. So three branches, but with that shared inspiration. Can you tell us a bit more about how they each approached it? Yeah. So you have evolution strategies. This was Reckenberg and Schweifel. They were all about using random mutations. Way to mutations. Yeah. To explore the search space. Imagine, like, a rugged terrain with peaks and valleys. Traditional algorithms, they might get stuck in a valley thinking it's the highest point, right? Right. But with these random changes, you can jump out of those valleys and find those higher peaks. Better solutions. So randomness is a tool. Exactly. Not a hindrance. That's a cool way to look at it. What about evolutionary programming? So Lawrence Fogel, he was the mind behind that. He was focused on these finite state machines, computational models. Okay. And he was using them to tackle prediction problems. So the problem-solving system itself was actually adapting, changing over time. He was pushing the boundaries of what we think of as programmable. And then there's genetic algorithms, which maybe a lot of our listeners have at least heard of. Yes. John Holland, he was really pivotal, drawing inspiration directly from Darwin. Really? He was mimicking reproduction, mutation, selection. Wow. And he came up with this really clever way of representing solutions. Okay. He used strings of bits, like chromosomes. So these digital genes could undergo this artificial selection recombination. It's like creating this digital ecosystem where these solutions can, like, compete and evolve. Exactly. It's survival of the fittest, but for algorithms. That's such a cool concept. Yeah. So you have these three branches, all drawing inspiration from nature. It's remarkable. But each one bringing something unique to the table. And eventually, they all come together under this umbrella term, evolutionary computation. I love that. So it was in the 90s that they kind of officially unified. It's like, you know, different scientific disciplines converging, leading to all sorts of breakthroughs. Absolutely. Now, there's this other piece of the puzzle, too, right? Genetic programming. Yes. John Koza comes along in the early 90s, and he's not evolving these data structures, you know, like those bit strings we were talking about. Oh, interesting. He's evolving actual computer programs. He's evolving programs. Okay, I need you to break this down for me. What does that actually look like? Well, picture this. You've got a whole population of programs. Each one is trying to solve a specific task. The programs that perform better are more likely to reproduce, right? They pass on their code. Okay. And then that code can be mutated, combined with other programs. It's constantly improving. Right. Driven by that survival of the fittest code. That's amazing. So we have natural selection, but in this digital world. Exactly. So we've got these core branches of evolutionary computation, evolution strategies, evolutionary programming, genetic algorithm. And genetic programming. Oh, right. And genetic programming. And they all draw from nature. But they each bring their own unique approach to solving problems. They do. Now let's get into the techniques themselves. Let's do it. It's interesting, you know, we've been talking about how evolutionary computation takes inspiration from biology. Yeah. But it's really a two-way street. Oh, interesting. So these evolutionary algorithms, they're not just inspired by biological systems. Okay. They're also being used to model and simulate them. So we're using computer science to study the very thing that inspired it. Exactly. We can gain insights into the dynamics of evolution itself. It's like this feedback loop. It is. Can you give me an example of how that works? Well, one really interesting area is evolutionary automata. Evolutionary automata. Yeah. They're self-replicating computer programs. Okay. So they evolve, they adapt within a set of rules, kind of like mimicking those biological systems. So like we're creating these digital petri dishes. Exactly. And we get to observe evolution in action. But we have control and speed. Yes. And you can learn so much from that. Has this approach led to any discoveries? Oh, absolutely. We've studied all sorts of things. Evolution of cooperation, multicellularity, how environmental pressure shape traits. Wow. All sorts of things. So we can rewind and replay the tape of evolution. In a way, yeah. That's amazing. And earlier you mentioned evolutionary Turing machines. Right. This is more theoretical, exploring what evolution can achieve, both in nature and in computation. Okay. It helps us understand the computational capabilities of evolutionary processes. So it begs the question, does the success of evolutionary computation suggest that evolution itself is just this powerful problem-solving process? It's an interesting point. I mean, the fact that we can use these evolutionary principles to solve real-world problems says something, right? Yeah. Evolutions had billions of years to refine its methods. I mean, who knows what other secrets are hidden in evolution? I know. We've barely scratched the surface. It makes you wonder if there are even more computational techniques just waiting to be discovered. Yeah. Bio-inspired computing is such a dynamic field. Yeah. Researchers are always looking to nature for inspiration. Ant colonies, the human immune system. So much potential out there. You're making me want to go do some research. Speaking of researchers, are there any big names in evolutionary computation? Oh, tons. John Holland, of course. He's considered the father of genetic algorithms. He laid the foundation. He really did. His book, Adaptation in Natural and Artificial Systems, is a classic. Essential reading. And then you have David E. Goldberg. His book on genetic algorithms is fantastic. Sounds like a must-read. Anyone else? Reckenberg and Schwefel, pioneers of evolution strategies. And, of course, John Koza, who championed genetic programming. It's amazing to see how all these different minds came together. I know. Shaped the field into what it is today. But it's not just individuals, right? Right. There's this vibrant community of researchers. Absolutely. So where can our listeners go to learn more or even connect with this community? There are some great journals out there. The Journal of Evolutionary Computation and IE Transactions on Evolutionary Computation. Keeping up with all the latest research. Exactly. What about conferences? Oh, yeah. The Genetic and Evolutionary Computation Conference, or GECCO, is a big one. Okay. Also the IE Congress on Evolutionary Computation, or CEC. So there are ways to really dive deep and connect with others? For sure. Now let's switch gears a bit. How is this technology being used in the real world? Okay, so we've covered a lot of ground. We've talked about where evolutionary computation came from, the theory behind it. Right. But now let's talk about its impact. Like, how is it actually being used to solve problems? It's being used in so many different fields, it's kind of mind-blowing. Give me some examples. Like, in engineering, how is it being used? Well, aerospace engineering is a great example. Evolutionary algorithms are being used to optimize aircraft design. Oh, wow. Like the shape of wings to make them more aerodynamic. To improve fuel efficiency. Exactly. And they're being used to design new materials that are lighter and stronger. So evolutionary computation is helping us build better planes. It is. What about other areas of engineering? Structural engineering. So you're designing bridges, buildings, and you want them to be safe, of course, but

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
