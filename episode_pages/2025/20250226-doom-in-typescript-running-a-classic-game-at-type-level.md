# Doom in TypeScript: Running a Classic Game at Type Level

**Published:** February 26, 2025  
**Duration:** 12m 56s  
**Episode ID:** 17692372

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17692372-doom-in-typescript-running-a-classic-game-at-type-level)**

## Description

A deep dive into a mind-bending project that pushes TypeScript's type system to its limits by running Doom entirely through types. We explore the motivations, the techniques (a type-level virtual machine, memory management, rendering), and what this means for the future of type systems in software engineering.

## Transcript

Welcome back to our series, you know, exploring all this cool stuff in computer science and software engineering. And today we're diving into something that sounds, well, impossible, honestly. Running in the classic video game Doom. But get this, entirely within TypeScript's type system. Yeah, exactly. It's not like we're talking about some port or like emulating it or anything like that. This is Doom, like the actual game running on the power of, well, types. You know, the stuff we usually just think about for defining data in our code. Okay, I'll be honest. I'm super skeptical right now. And, you know, I think our listeners probably are too. It sounds like, well, an elaborate joke, right? I get it. I totally understand why you think that. But trust me, this is a real project. It's massive, actually. We're talking about 3.5 trillion lines of code. 3.5 trillion, 177 terabytes of data. And just to render the first frame, it took 12 days of processing. 12 days for one frame. I mean, most games we're playing are rendering like, what, dozens of frames every second. Yeah, exactly. But the thing is, this project wasn't about speed or anything like that. It was about, you know, seeing how far you could push a type system, like to its absolute limit. The guy who made this, he's, well, a pretty well-known TypeScript enthusiast. And he wanted to find that breaking point. Where would Doom, where would it just, you know, refuse to run? So this is the same guy, right? The one behind all those crazy type challenge videos that, well, make even experienced developers kind of sweat a little. Yep, that's the one. Clearly he likes, you know, a good challenge. But this is beyond just some complex type puzzle, right? This is like he basically built an entire virtual computer, but inside of TypeScript's type system. Okay, hold on. A virtual machine, but made of types? I'm not sure I follow that. So imagine, like, you're building a computer, but instead of circuits and chips, you're using, I don't know, Lego bricks, right? Each brick is a type, and you're connecting them together. And somehow he made a machine that actually works. It has RAM, a CPU, a call stack, you know, all the things a real computer needs. Okay, so this Lego computer, how's it actually running Doom? It's not like, you know, you just pop in a game cartridge. Right, right. He had to translate every single piece of the game into types. The maps, the textures, how the enemies move, everything. All of that encoded using nothing but TypeScript's type system. To pull that off, he had to implement some, well, some crazy stuff that you wouldn't normally even think about doing with types. Like what? Give us some examples. Well, for one, he made a garbage collector, you know, for managing memory. Normally that's handled by, you know, the language itself, not something you'd build within a type system. That's wild. Okay, now I'm starting to see how this goes way beyond some, like, clever tricks. It's like redefining what a type system even is, isn't it? Yeah, for sure. He also did things like he built a CPU cache to speed things up, a memory compactor to, you know, use less memory. Even a way to handle exceptions, all using types. The amount of creativity and, well, deep understanding of the game and TypeScript here, it's insane. This is mind-blowing. But what about tools, right? How do you manage a program with 3.5 trillion lines of code? I can't imagine trying to debug something like that. And that's where it gets even crazier. Most of the tools that developers use, they just couldn't handle something this big. Forget about things like syntax highlighting or auto-completion. Just loading the files into an editor was a challenge. It's like he was working in the dark, relying on his knowledge of the type system and, I guess, a lot of trial and error. So not only is this pushing TypeScript to its limits, but also, you know, what a human can even code and manage. But if the usual tools didn't work, how did he even know if things were, well, working correctly? Well, think about it. It took 12 days just to render one frame. Right, but how did he even know that one frame was right? Was he, like, just staring at compiler output for two weeks? He had to come up with some very creative workarounds. So the final output of this program is actually, it's a TypeScript object. And each value in that object represents a pixel on the screen. But TypeScript doesn't have any way to, you know, visualize something like that. So he had to build that too. There seems to be a pattern here. Exactly. He made a separate program just to take that output and turn it into an image file. It was like building his own debugger from scratch. Okay, I'm officially speechless. This is less like programming and more like some kind of performance art. But I have to ask, why even go through all this? Was there a goal besides, you know, just proving it could be done? That's a question we're going to dig into in the next part of our deep dive. Because this project wasn't just about, you know, technical wizardry. It was about challenging assumptions, pushing the limits of what we understand, and maybe even seeing a future where, well, where the lines between code and data start to blur. Yeah, this is definitely a lot to take in. I think we all need a moment to, you know, let it sink in before we keep going on this incredible journey. Stay tuned because we're just getting started. Welcome back to our deep dive, you know, into this crazy world where Doom is running on TypeScript types. So, you know, I'm still kind of wrapping my head around all this. We've covered like the how part, you know, the mind-blowing technical stuff. But I think it's time to talk about the why. What made this guy, what made him decide to spend like a year on this, you know, this coding odyssey? It is fascinating, isn't it? I mean, at first glance, you might think, oh, this is just someone showing off, right? But, you know, I think there's something deeper going on here. Okay, I'm listening. Tell me more. So his original goal, it wasn't actually to get Doom to run. He wanted to prove that it couldn't be done, you know, to find like that fundamental limit, that brick wall that would stop Doom in a type system. So it was like he was trying to debunk the whole idea. Yeah, exactly. But here's the thing. With every roadblock he hit, every like impossible obstacle, he found a way around it. And, you know, instead of confirming his initial belief, it's like these challenges, they just made him even more determined. So wait, so it's like a self-fulfilling prophecy. The more he tried to prove it couldn't be done, the closer he got to actually doing it. Exactly. And I think this tells us something important about, well, about innovation in computer science. We often set limits based on, you know, what we know, what we think is possible. But this project, it shows us that those limits, they're often, you know, self-imposed. Yeah, it's like it's a good reminder, you know. Sometimes you got to question what you think you know, you know, go outside that comfort zone, and you might discover something amazing. But let's be real. This project, it involves some, well, some pretty extreme measures. Turning off safety checks, pushing the hardware to the edge, and writing code that's like impossible to debug. Yeah. That's not how we're supposed to build software, right? Oh, absolutely. This is definitely not like a how-to guide, right? It's not about like building real-world software this way. But that's not the point. This is about, you know, exploration, pushing the limits, seeing what's possible. And in doing that, you know, maybe we uncover new knowledge, new insights that, well, that could have a big impact down the line. So you're saying even though we won't be seeing like type-powered operating systems or video games anytime soon, maybe the ideas behind this project, you know, that they could change how we think about programming in the future. That's the idea. Imagine, right, being able to use a type system not just to catch errors, but to like formally verify that software is correct. Like think about flight control systems or medical devices, right? Or imagine generating highly optimized code just for specific hardware, you know, through the power of types. It's pretty mind-blowing. Yeah, yeah, I can see that. It's, you know, it's pretty compelling. And I can see how this kind of, you know, creative problem solving, the deep understanding of type systems here, it could lead to those kinds of advancements. Definitely. I mean, this project, it highlights a trend that's been growing in computer science. People are starting to see that type systems, they're more than just, you know, for defining data. They can be powerful tools for making software reliable and fast. It's like we're starting to realize, you know, type systems aren't just about data. They're about expressing logic and constraints and even like complex calculations, but in a way that can be, you know, rigorously checked and verified. Exactly. And who knows, maybe someday we'll look back at this project and see it as, you know, the thing that kicked off a whole revolution in how we use type systems.

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
