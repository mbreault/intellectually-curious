# Patrick Collison: From Lisp to Stripe â€” A Deep Dive into the Future of Software

**Published:** July 16, 2025  
**Duration:** 14m 0s  
**Episode ID:** 17693114

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17693114-patrick-collison-from-lisp-to-stripe-â€”-a-deep-dive-into-the-future-of-software)**

## Description

ADeep dive into Stripe co-founder Patrick Collisonâ€™s mindset: the Lisp and AI roots, pragmatic bets on Ruby and MongoDB, the evolution of Stripeâ€™s API, and his forward-looking perspective on AI-augmented programming and the next generation of software tools.

## Transcript

Welcome to The Deep Dive. Today we're plunging into the really fascinating mind of Patrick Collison, co-founder of Stripe. Right, a huge name, obviously. Absolutely. But he's known for building this massive company, Stripe, yet what's truly compelling, I think, is his perspective. He's not just an entrepreneur. No, he's a programmer at heart, a really curious one, and interestingly, kind of an economist, too. Exactly. It's that blend that makes him so interesting, especially if you're into computer science, software engineering, you know, where things are headed. So this deep dive, we're really going to unpack his journey, looking at how he saw programming evolve, the big tech choices he made along the way. Pivotal choices, really. Yeah, and his thoughts looking forward on AI, even biology, which is maybe surprising to some. We'll see how those early experiences still kind of echo in his thinking today. And our mission here really is to pull out the key lessons, the nuggets of knowledge from what Patrick Collison has done and said, kind of a shortcut, if you will, to understanding the bigger picture. The why behind the what. Exactly, the trajectory of software and, well, its broader impact. Okay, let's jump in. We should probably start way back, right? Before Stripe, his early programming years. Definitely. Because that's where you see the roots of his approach. And this is where it gets really interesting, I think. He was working with Lisp. Lisp dialects, even Lisp web frameworks. Which was pretty unconventional, even back then. Very. It wasn't the standard path, but it clearly fundamentally shaped how he thought about software. And one of the standout things from that time was his AI bot for MSN Messenger. Remember that? Vaguely. What did it do? Well, he wrote it in Lisp and it used a pretty simple Bayesian next word predictor. Okay, like predictive text on your phone, sort of. Kind of like that, yeah. Trained on its own conversations. And the goal, incredibly ambitious, was to pass the Turing test. Wow. Did it? No. Unsuccessful on that front. But that project is what got him into Lisp. And he mentioned Peter Norvig's book, Paradigms of AI Programming, was like super formative for him then. And he wasn't just doing AI bots. He was messing with genetic algorithms too. Yeah. Created an optimizer to figure out the best keyboard layout. Seriously. What did it come up with? He concluded it was basically V4JAC, which is, I mean, completely non-standard. Yeah. So he actually used it. He and his brother John, yeah, apparently made their computers totally unusable for anyone else. That's commitment to optimization, I guess. It really shows that experimental streak he had early on, just trying things out. Yeah. It's also interesting what he didn't explore back then. Right. He noted he never really experimented seriously with neural networks, just the sheer computational cost at the time, which obviously is a massive contrast to now. Huge contrast. And thinking about influences, around 2008, this is after he sold his first startup. Octomatic, yeah. He made this prediction. He thought mainstream languages, you know, C-style languages, would start borrowing more ideas from older ones. Like Lisp and Smalltalk. Exactly. And you look at JavaScript, Python today, he kind of nailed that trend, didn't he? He really did. It shows he was thinking deeply about language evolution even then. So, okay, he's got these ideas about programming, this Lisp influence. Then comes his first startup, pre-Stripe. Shutterstock was, no, wait. Octomatic was the first one he sold? Yeah. The one after that, which didn't succeed, was where the Smalltalk story comes in. Right, right. Okay, so they initially tried Ruby on Rails there. Yeah, the standard choice at the time. But he found it frustrating compared to Lisp. Oh, yeah, exactly. It goes back to that core philosophy. He missed that interactive, live coding feel he got from Lisp. So what did he do? He found this continuation-based web framework in Smalltalk. Smalltalk, another unconventional choice. Definitely. But he was apparently captivated by its IDE, its development environment. He said it was powerful, like Lisp. Ah, so? Fully interactive, a proper debugger, and this ability to edit code while it was running, fix an error mid-request, and then just resume the request immediately. Okay, I can see the appeal. That avoids the whole stop, recompile, redeploy cycle? Exactly. Cuts down those frustrating feedback loops massively. But he's pretty honest about it now. He says using Smalltalk was, quote, a terrible decision in hindsight. For some reasons, yeah. Probably scaling, hiring maybe. Though he did say it was surprisingly easy to teach new hires. But the key lesson he took away, it wasn't the language's fault the company failed. Right. He stressed that the idea wasn't that strong, the market fit wasn't there. Which is such a crucial point. It really is. And here's the kicker. When that company got acquired, mostly for the team. What happened to the Smalltalk code? Thrown out, immediately discarded, it didn't live on. Wow. That's a stark contrast to what happened later with Stripe, isn't it? A very stark contrast. It underlines that the tech, however clever, isn't enough without a solid business foundation. Which brings us neatly to 2010. Stripe, Patrick and his brother John. They've learned some lessons. You'd think so, yeah. And they have to make those foundational tech choices again. What did they pick this time? Okay, so for the main language, they went with Ruby. Ruby? Why Ruby? Well, they wanted something mainstream, but maybe, as he put it, less heterodox than Java. Trying to find that balance, you know. Pragmatism meets developer efficiency. Okay, makes sense. And the database? No SQL objection this time? Well, that's interesting. They chose MongoDB. Mongo. Okay, no SQL. Right. And apparently the decision was super informal, like sitting on the couch, like, should we use Mongo? Yeah, fine. Really? That's the story. But he did say there was a principled objection to SQL underlying it. He wanted something object-based, flexible, but still more established than, you know, writing their own from scratch. So Ruby and MongoDB, how did those bets pay off? Because Stripe became, well, Stripe. Massively successful. And remarkably, Ruby and Mongo are still foundational parts of their stack. Still, after all this time and scale. Yeah. They obviously had to build a ton of infrastructure around MongoDB to make it fault-tolerant, distributed, super reliable. You hear about their uptime stats, right? They're legendary. They are, like, 99.99986% API availability, which works out to something crazy like 44 seconds of downtime per year. That's insane reliability, especially built on Mongo back then. It really highlights the impact of those early choices, but also the engineering effort to make them scale. They didn't just pick them and hope. Did they stick only with Ruby, though, as they scaled? No, they did adapt. For certain high-throughput services, they did a partial migration to Java. Ruby hit performance limits. So now they use both. Exactly. Shows that willingness to evolve pragmatically without just ripping everything out. And speaking of evolution, there's this Stripe V2 API thing. That sounds like a major undertaking. Oh, it is. Starting around 2022, they realized some of the original V1 abstractions weren't quite right for the long haul. So they're changing the core API. That sounds risky for users. Well, here's where some early foresight really paid off. Back in 2010, they pre-filled all their API endpoints with V1. Smart. Very smart. So now they can introduce V2 without breaking everyone's existing integrations. They just increment the namespace. And what's the goal of V2? It's about unifying concepts that were separate before. Things like end customers, connected accounts. Making them a single coherent representation. It's complex, multi-year, but it's shipping now. Okay, shifting gears a bit. Let's talk about the future of programming through Collison's eyes. He uses AI tools, right? LLMs? He does. He mentioned using chat tools, but mainly for factual questions. Empirical stuff. Not for writing prose. Apparently not. Finds they lack personal style, but he does use them for writing code. Directly. Usually through an intermediary tool like Cursor. So if he's using AI for code, how does he see software development changing more broadly? This is really interesting. He actually advocates for a return to something like the old Lisp machines or Smalltalk environments. Really? Integrated development environments. Yeah, where the runtime and the editor are deeply, deeply connected. Not separate things like they often are today. And where does AI fit into that vision? He hopes AI can take on the burden of refactoring, of beautification, he called it. Making large code bases less intimidating, easier to change. Like an AI assistant constantly cleaning up the code. Almost like that, yeah. He said maybe an AI nocturnally tidying things up. He even connected it back to his only CS class with Jerry Sussman, which was all about designing code bases you could actually modify later. That resonates. The weight of legacy code is real. So for developers listening, what does that future look like in, say, five years, according to him? He hopes tools like Cursor might evolve beyond just showing raw code. Maybe we'll interact with higher level, less formal languages. More focused on the what than the how. Exactly. Perhaps even manipulating the UI directly to generate code. Less typing, more directing.

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
