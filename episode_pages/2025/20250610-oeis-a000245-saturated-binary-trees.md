# OEIS A000245 Saturated Binary Trees

**Published:** June 10, 2025  
**Duration:** 13m 48s  
**Episode ID:** 17693015

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17693015-oeis-a000245-saturated-binary-trees)**

## Description

Learn about OEIS A000245 Saturated Binary Trees

## Transcript

Welcome to the Duck Dive. This is where we take a whole stack of information, zero in on what really matters, and try to build some understanding together. And this time we're continuing our series looking at the online encyclopedia of integer sequences. Specifically for you number theory students out there, we're tackling sequence A000245. Right, a fascinating one. We're going to explore its, let's say, mathematical origins and then see how it connects, maybe in ways you wouldn't expect, to binary trees. Specific concepts there. Okay, so we've got the OEIS page for A000245 itself, naturally. Yep, and some foundational stuff on binary search trees, complete binary trees, the textbook material students often see. And even a glimpse of some online discussion, like a Reddit thread, maybe showing how these ideas get talked about in practice. Exactly, so the mission is to, you know, unpack all this and see how an abstract-seeming sequence links up with these, well, very concrete data structures. Seeing the forest and the trees, you might say. So if you're into number theory, use the OEIS or just, you know, love finding those hidden connections in math, this should be interesting. Definitely. So let's start with the sequence itself, A000245. The OEIS lists the first few terms as 0, 1, 3, 9, 28, 90, 97, 1001, 3432, and so on. Okay, 0, 1, 3, 9, 28. Not immediately obvious maybe what's the definition. Well, the OEIS page gives a defining formula. It's AN equals 3 times 2, that's factorial, divided by the product of N plus 2 and N1. Whoa, okay, lots of factorials. That usually screams combinatorics, doesn't it? Counting things. It really does. But the OEIS provides a perhaps more familiar connection right off the bat, especially for number theorists. A really key point on the page is its relationship to the Catalan numbers, that's sequence A000108. Ah, Catalan. Okay, those I know. Balanced parentheses, paths on a grid. They're everywhere. Exactly. And this sequence, A000245, specifically AN, is the first difference of the Catalan numbers. So AN, Catalan plus 1 minus Catalan. Interesting. So it's built directly from them. Right. And there's another formula mentioned for N greater than 0, when AN equals 3N divided by N plus 2 times Catalan. So very tightly linked. Knowing it's tied to Catalan numbers is a huge clue then, because Catalan numbers count so many different structures. It absolutely is. And the OEIS page for A000245 backs this up. It lists numerous different combinatorial interpretations, basically different kinds of things that this sequence counts. Okay. And this is where we start seeing hints of tree-like structures. For instance, one interpretation is that AN counts the number of Dick paths of length 2N plus 1 that start with two up steps. Okay, hold on. Dick paths, those are the grid paths, up and right steps or up and down, depending on convention, that don't dip below the diagonal, right? That's the usual idea, yes. And Catalan numbers count the standard Dick paths. So A000245 is counting a specific type of Dick path, ones that are a bit longer and start a certain way. Precisely, a specific subset. And the OEIS source gives other interpretations too, like certain lattice paths touching a line, permutations avoiding patterns. Right, the usual combinatorial zoo that OEIS is so good at cataloging. But critically, for our discussion, it also lists interpretations directly in terms of trees. Ah, okay. It says it counts rooted trees with N plus 1 nodes where the root has degree greater than or equal to 2. Degree greater than or equal to 2. So the root has at least two children. Yes. And another one. Rooted trees with N plus 2 nodes where the root has degree at least 1 and the rightmost path has length at least 2. Okay, now we're talking trees directly. So it's not just that it's related to things like Dick paths, which can be mapped to trees. The OEIS is saying this sequence literally counts certain kinds of rooted trees. Exactly. That's a much stronger, more direct link than just the Catalan connection, although that's related, of course. The specific tree interpretations listed in the OEIS are crucial. So A000245 doesn't count, say, all binary trees of a certain size or anything that simple? No, not all of them. It's counting very particular subclasses defined by these kinds of properties, the root's degree or something about the structure of the rightmost path, things like that. Got it. Okay, so let's maybe put a pin in A000245 for a second, knowing it counts these specific trees. Let's talk about the tree structures themselves based on our other sources, binary trees. Right, good idea. So one fundamental type is the binary search tree, the BST. The classic. The classic. And the sources define it as a rooted binary tree where, for any node, the key or value in that node is greater than everything in its left subtree and less than everything in its right subtree. And that ordering is the whole point, right? That's what makes them useful for searching, insertion, deletion, hopefully fast. Exactly. Usually O log N time on average, which is great. The sources cover the basic operations, how you search, either recursively or iteratively. How you insert new nodes, which always end up as leaves. And deletion, which has those slightly fiddly cases depending on whether the node has zero, one, or two children. Yeah, deletion can be tricky. It can. And the sources also mention traversals, like in-order traversal, which for a BST gives you the nodes in sorted order. A very neat property. But there's a catch with BSTs, isn't there? They're not always O log N. The sources mention degeneracy. Ah, yes. The potential downside, if you insert data in a specific order, like, say, already sorted data. Right. Smallest, then next smallest, et cetera. Then the tree can become completely unbalanced. It essentially turns into just a linked list. And then your search time goes from O log N to O N, which is bad. Very bad. And that's why the sources mention balancing techniques. Things like AVL trees, red-black trees, ways to automatically restructure the tree during insertions and deletions to guarantee it stays reasonably balanced and keeps that O log N performance. Okay, so BSTs are about order, and balancing is about maintaining performance. Now, what about the other tree concept mentioned, this idea of a complete binary tree? That sounds like a different kind of property. It is. It's about structural density or saturation, as you put it. The definition in the source is quite specific. A complete binary tree is one where all levels are completely filled except possibly the last level. And crucially, on that last level, all the nodes must be as far to the left as possible. No gaps on the left. Ah, okay, so you fill it top to bottom, left to right, without leaving any holes until you absolutely have to at the very end. Exactly. It's like pouring water into a container. It fills up level by level from the left. How does that compare to, say, a perfect binary tree or a full binary tree? The sources distinguish these. Right, a perfect binary tree is stricter. Every level must be completely full. All leaves are at the same depth. So a perfect triangle shape. Pretty much. And a full binary tree is different again. That just means every node has either zero children, it's a leaf, or exactly two children. No nodes with just one child. Okay, so a tree could be full but not complete. Yes. Imagine a full tree where the last level has nodes, but maybe there's a gap on the left side. It's full. All nodes have zero or two children, but not complete because the last level isn't packed to the left. A perfect tree is always full and complete, though. Got it. And the sources mention a really practical aspect of complete trees. Their array representation. Yes, this is a key advantage. Because they are so densely packed and left-aligned, you can store a complete binary tree with N nodes perfectly in an array of size N. No wasted space. And there are simple formulas to find children or parents. Yep, if the root is at index zero in the array, then the node at index I has its left child at 2I plus 1 and its right child at 2I plus 2. Going the other way, the parent of node I, if it's not the root, is at floor I1, 2. Super efficient. And that's why they're used for things like binary heaps, right? Which are used in heap sort. Exactly. That array mapping is fundamental to how heaps work. Okay, so we've got A000245 counting specific kinds of rooted trees. And we have these definitions for BSTs, ordered, maybe balanced, and complete trees, structurally dense, array-friendly. How do we really nail the connection? Is A000245 counting complete trees? No, it's not directly counting all complete binary trees nor all BSTs. The connection is more subtle, but it comes back to those specific combinatorial interpretations from the OEIS. A000245 counts rooted trees that satisfy certain structural conditions, like the root having degree 2. And these conditions often arise naturally when you map other combinatorial objects, like those specific dict paths, onto trees. Can you maybe walk through that dict path mapping? How does a path starting U relate to a tree structure? Sure, let's try a common mapping. You can build a rooted

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
