# OEIS A000329: Tangent Iteration Sequence

**Published:** September 05, 2025  
**Duration:** 4m 51s  
**Episode ID:** 17794467

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17794467-oeis-a000329-tangent-iteration-sequence)**

## Description

<p>We explore A000329, the tangent-iteration sequence defined by b(0) = 1 and the nearest integer to b(n), where b(n) = tan(b(n-1)). The interplay between the continuous, blow-up behavior of tan near odd multiples of Ï€/2 and the discrete rounding step yields a surprisingly erratic sequence (with terms wandering through 1, 2, 75, -1, -1, -2 â€¦ and beyond). We unpack how the sensitivity of tan to its input, combined with rounding, acts as a powerful nonlinearity that can send the next term in a completely different direction from tiny fluctuations. This makes numerical computation extremely delicate: standard floating-point is far from enough, and interval arithmetic or very high-precision arithmetic are used to bound errors and verify terms. Some computations reportedly require tens of thousands of bits of precision to stay on the true trajectory, illustrating the fragile, chaotic-like dynamics of a simple rule. Weâ€™ll also discuss how small changes in the starting value could dramatically alter the long-term behavior and what this reveals about deterministic maps in number theory and numerical analysis.</p>

## Transcript

Welcome back to The Deep Dive. We're digging into the OEIS again, the Online Encyclopedia of Integer Sequences, with a focus for you number theory students. Today we've got OEIS A000329 lined up. It's known as the tangent iteration sequence. Hmm. Sounds simple enough, but well, you'll see. It gets pretty wild. It really does. So the definition itself is quite clear. You find the nearest integer to bn n. And this bn is just tan bn bn-1. Critically, you started off with b0 equals 1. Okay, so you take 1, find its tangent, round it. Round it to the nearest integer, yep. That gives you a 0, then you use that result, take its tangent, round again, and so on. It's an iterative process. Got it. And the source gives the first few terms. There's something else. It starts 1, 2, 7, 5. Okay, maybe growing fast. But then bam, it hits 9, 1, 9, 1, it goes 2. Then later you see things like 1, 2, 3, 1, and even sequences of 0, 0, 0, 9. But just seems all over the place. It is remarkably erratic. So let's try and unpack this. What's going on under the hood here? Well, our mission really is to understand how the tangent function's nature interacts with this nearest integer rounding. And also, crucially, the kind of computational precision you actually need to follow this sequence for any length of time. Right, those initial terms are fascinating. 1, 2, 75. Yeah. Then the sudden jump to negatives. Then back to positives, then zeros. It feels almost random. It does seem that way. What's really going on is this interplay, this dance, as you might call it, between the continuous nature of the tangent function and the discrete jump caused by rounding. Explain that a bit more. The tangent function itself can behave wildly, right? Near multiples of pi over 2. Exactly. Tangent shoots off towards positive or negative infinity, but then no matter how large or small that tangent value is, the rounding step forces it, snaps it back to a single integer. Think about values near a half integer boundary, like say 74.49 versus 74.51 after taking the tangent. Ah, one rounds down to 74, the other rounds up to 75. Precisely. And that single integer difference can send the next iteration off in a completely different direction because the tangent function is so sensitive itself. So that rounding isn't just a minor detail. You called it a mathematical lever. It's actually driving the complexity. Absolutely. It introduces a significant non-linearity. You expect iterative functions to be deterministic, but this rounding amplifies tiny, tiny differences in the decimal part. It's like a mathematical butterfly effect happening at potentially every single step. A minuscule difference in bn1 might lead to a completely different integer for an. Which explains why predictable patterns are so hard to find. And why you need such incredible accuracy to compute the terms. Yeah, let's talk about that. The source mentions needing really high precision, even mentioning interval arithmetic. Why is that necessary? It sounds computationally intense. It is incredibly intense. You need that precision because of the sensitivity we just discussed. Standard computer floating point numbers, like double precision, they just aren't accurate enough. An error, even a tiny one, like 10 to the minus 15 in calculating the tangent, can grow very rapidly. After just a few steps, that small error could cause you to round to the wrong integer entirely. So you'd be following a completely different sequence path without even knowing it. Exactly. Interval arithmetic helps because it tracks a range of possible values at each step, essentially keeping bounds on the accumulating uncertainty. The source notes needing calculations starting with maybe 70,000 bits of precision for some terms, like finding out 1164189. That's just immense. Wow, 70,000 bits. That really drives home how demanding this seemingly simple sequence is. It's a constant battle against numerical error to stay on the true path of the sequence. Okay, so to recap briefly, we have a straightforward rule, take the tangent, round to the nearest integer, repeat. But this combination creates this incredibly complex, almost unpredictable sequence. It really highlights how simple mathematical operations can lead to really emergent, complex behavior. And it shows the limits of standard computation. Perfectly put. The computational demand isn't just a side note. It's fundamental to understanding the sequence's nature. And that leads to a rather provocative thought connecting to the bigger picture of iterative systems in mathematics. Think about this. The sequence we discussed, A000329, it starts with B001. What if? What if you tweaked that starting value just a tiny bit, say to 1.000001 or maybe 0.99999? How might that infinitesimal change affect the entire sequence down the line? Given the sensitivity we discussed, probably dramatically. Probably. Exploring that could tell you a lot about the inherent sensitivity, maybe even the chaotic potential lurking within many seemingly simple mathematical processes. It's definitely something interesting to ponder.

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
