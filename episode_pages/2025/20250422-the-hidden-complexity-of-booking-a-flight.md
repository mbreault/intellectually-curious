# The Hidden Complexity of Booking a Flight

**Published:** April 22, 2025  
**Duration:** 12m 34s  
**Episode ID:** 17692150

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17692150-the-hidden-complexity-of-booking-a-flight)**

## Description

In this Deep Dive, we pull back the curtain on online flight pricingâ€”from routes and fare components to priceable units and airline inventory. We explore why computing the cheapest itinerary is NP-hard (and sometimes EXP-space hard in theory), how search is pruned with heuristics and caching, and how these ideas connect to prompt engineering.

## Transcript

Welcome to the Deep Dive. We're continuing our series on computer science and software engineering today. And we're tackling something most people have done, booking a flight online. Right. Seems pretty straightforward, you know. Put in your cities, your dates, click search. Uh-huh. But underneath that simple interface, it's actually, well, incredibly complex computationally. And that's what we're diving into, that hidden complexity, looking at airline pricing and how it kind of relates to ideas from prompt engineering. Exactly. Think of your flight search Chicago to Denver, say, as a prompt. You're asking this huge system a question. And the system has to navigate this maze of rules and possibilities to give you an answer, the price. We want to pull back the curtain on why it's such a challenge, why finding a cheap flight feels like solving a puzzle sometimes. Yeah, hopefully leading to some aha moments for everyone listening. We're drawing on some great sources today, an overview of ITA Software's engine, and a talk focused on the sheer computational difficulty. So let's start with just the scale. The flight network itself is huge. How huge are we talking? Well, think about 30 million scheduled flights every year, something like that, connecting maybe 4,000 commercial airports globally. Okay, that's a lot of dots to connect. It is. But finding one way to get between two cities, say, San Francisco to Boston, from a computer science view, that's not the hard part. It's a basic graph problem, finding a path. Right, like finding a road on a map. Simple enough. Exactly. The complexity explodes when you want, like, all the reasonable ways, the fast ones, the ones with decent connections. Ah, okay, so not just any path, but the ones a real person might actually consider taking. Precisely. The sources mentioned SFO to Boston, same-day travel. You could be looking at around 30,000 different combinations of flights. 30,000 for one day? And if you say, okay, I'm willing to have an overnight layover somewhere, that number jumps into the billions, billions of potential paths. Wow. Okay, so the sheer number of routes is staggering. That's the first layer. That's the first layer. But here's the kicker. Finding those routes, that's actually the easier part of the whole problem. Really? What's harder than navigating billions of options? Pricing them. The real beast here is figuring out the cost based on the airline's incredibly complex pricing rules. Okay, let's get into that. The pricing rules. Right. So you need to understand the building blocks. First, you have the fare. Okay. A fare is basically the price for a one-way trip between two cities, a market. But crucially, it comes with a whole list of rules. Rules like what? Oh, minimum stay, maximum stay, whether you need to buy in advance, which days you can travel, sometimes even which flights you can use. It's not just a price. It's a price with conditions. Got it. Price plus fine print. Exactly. Then you have a fare component, or FC, that's just a specific fare applied to the actual flight segments it covers in your itinerary. So the fare is the potential price. The fare component is that price assigned to a specific part of my journey. Yep. And every single flight leg in your trip has to be covered by exactly one fare component. Okay. And then things get really interesting with priceable units, or PUs. Priceable units sounds technical. It is, a bit. Think of them as like molecules built from fare components. They combine one to four fare components into fixed shapes. Shapes? Like what kind of shapes? Like a simple one-way trip or a standard round trip. Or maybe an open jaw trip where you fly into one city and out of another. Or a circle trip hitting multiple cities. Okay, so PUs are like templates for common trip types built from those fare components. That's a good way to put it. And here's why they matter so much. A lot of the really impactful fare rules, they don't apply just to the individual fare. They apply at the priceable unit level. Ah, okay. Give me an example. The classic one is the Saturday night stay requirement for cheap round trip fares. Right. Everyone's favorite rule. Exactly. That rule is often tied to the round trip PU. The rule says your trip, this PU, must include a Saturday night. And often that same cheap fare cannot be used at all if you try to structure your trip as a one-way PU. I see. So the shape of the trip, the PU, determines if you can even access certain cheap fares or if you have to follow certain rules. It's not just about the individual flights. Precisely. The airline isn't just pricing flight A and flight B separately. They're pricing the combination, the round trip PU, and attaching rules to that structure. That explains a lot. It's like buying ingredients versus a set meal deal with its own conditions. Good analogy. And it gets more complex. You have combinability rules. Meaning? Like maybe all the fares within one priceable unit have to belong to the same airline. Or maybe partner airlines are okay. It adds another layer of constraints. So many constraints. And here's another twist. A single set of flights, say Chicago, Denver, Chicago, could potentially be broken down into fare components and then grouped into PUs in multiple different ways. Wait, so the same flights could be priced differently depending on how you bundle them into these PUs? Yes, exactly. Maybe you price it as one round trip PU. Or maybe under certain circumstances you can price it as two separate one-way PUs. And that might change which rules apply or how they're interpreted. Precisely. Think about that Saturday night stay rule again or an advanced purchase rule. How you group the fare components into PUs can affect whether you meet the condition. This flexibility, this non-determinism, just explodes the search space again. Because the system has to try all the valid ways of grouping. You got it. And these PUs create what the sources call long-distance dependencies. A rule that applies because of how your whole trip, the PU is structured, might be affected by flights days apart. It sounds computationally nightmarish. It really is. Which brings us to the work by Carl DeMarkin, looking at the actual computational complexity. Okay, let's hear it. How bad is it? He proved that even simplified versions of this problem are NP-hard. NP-hard. Okay, translate that for us. What does that mean in practice? It means there's no known efficient algorithm guaranteed to find the absolute mathematically best, cheapest answer in all cases. No quick solution. Right. As a problem gets bigger, more flights, more fares, more rules, the time needed to check, every single possibility blows up exponentially. Brute force is just impossible. So finding the absolute rock-bottom cheapest price might be computationally infeasible most of the time. For complex trips, yes. That's why search engines aim for very good answers, maybe the best they can find quickly, but not always the theoretical optimum. Trying to check every single way to package and price an itinerary. Forget it. Okay, NP-hard is bad enough, but you mentioned he went further. He did. The full, unrestricted problem with all the interacting rules, fares, PUs, it can be classified as EXP-space hard. EXP-space hard. That sounds worse. It is, significantly worse than NP-hard. It implies the memory or computational space needed could also grow exponentially, and in some theoretical edge cases, the problem might even be undecidable. Undecidable, meaning you can't even guarantee you can find an answer no matter how much computing power you throw at it. In certain theoretical formulations, yes. It highlights the profound depth of the challenge. That's mind-blowing. We're just trying to book a flight. I know. Now, in practice, systems don't hit undecidable walls constantly. They use incredibly clever tricks. Like what? How do they cope? They use layers of heuristics, smart shortcuts, really to guess which paths and pricing combinations are most likely to be good. So educated guesses to narrow things down. Exactly. And aggressive pruning. If they can prove early on that one path is already more expensive than another complete solution they found, they just discard it. It's called dominance pruning. Makes sense. Don't waste time on losers. Right. And massive amounts of caching. Pre-calculating parts of the problem, storing results of common fair rule checks, things like compiling fair rules into efficient data structures like finite state transducers, memoizing partial tickets, anything to avoid redoing work. So it's a constant battle using smart algorithms and caching to fight that exponential complexity. Absolutely. And we haven't even talked properly about seat availability yet. Oh, right. Because it's not just about price. It's whether a seat is actually available at that price. And availability isn't just yes or no. Airlines manage inventory using a whole alphabet of booking codes, Y, B, M, H, Q, K, L, et cetera, tied to different fare levels and cabin classes. Fare buckets. Exactly. So availability is actually a vector, like we have five seats left in Q class, two in M, zero in K. And these counts change constantly based on demand and the airline's revenue management system. Which is trying to maximize how much money they make on that flight. Precisely. So the cheap fare bucket you want might be empty, even if the plane has empty seats, because the airline hopes to sell those seats at a higher fare later. And the sheer number of times people check availability must be huge. Astronomical. Yeah. The sources mentioned potential peaks of millions of availability checks per second across the industry. Millions per second. Yeah. That's why massive distributed caches are essential. Companies like ITA build systems to cache availability data so they only have

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
