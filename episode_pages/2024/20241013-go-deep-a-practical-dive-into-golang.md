# Go Deep: A Practical Dive into Golang

**Published:** October 13, 2024  
**Duration:** 12m 26s  
**Episode ID:** 17692469

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17692469-go-deep-a-practical-dive-into-golang)**

## Description

A practical tour of Goâ€”from its Google roots and community-driven open source to core concepts like error handling, defer, memory management, and embedding. We unpack the big ideas behind goroutines and channels, the generics era, and how Effective Go shapes real-world codeâ€”with a focus on the trade-offs, pitfalls like data races, and the languageâ€™s bold design choices.

## Transcript

All right, ready for a deep dive today? We're tackling Go. You know, Golang. It's everywhere you turn these days and we're going to break it all down. Yeah, and we've got the goods to do it. Official documentation, effective Go, even that Wikipedia rabbit hole. We're going deep. Love it. No stone unturned. So, Go. Golang. Why is everyone making such a fuss? Well, imagine it's like 2007. You're at Google. Maybe you're Robert Griezmer or Rob Pike or, you know, Ken Thompson. Hold on, Ken Thompson. As in, Unix Ken Thompson. The one and only. So these guys, they're facing the limits of what's out there language-wise. And boom, Go is born. Talk about a pedigree. But Google made it, yet it's open source. How does that work? Right, so anyone can jump in, contribute, use it, change it, the whole nine yards. It's a language by the community, for the community. That's a big part of its appeal. Gotcha. So no corporate overlords. Now, effective Go is pretty clear. Just translating, say, your Java code directly into Go, that's not going to fly. Why is that? It's deeper than just the words you use, you see. It's a whole new way of thinking. Effective Go calls them Go's idioms. Like, take functions, right? In Go, they can return multiple values. It's wild. And that changes how errors are handled. Everything's connected. Multiple values. All right, now you've got my attention. How does that even work, and what makes it better for errors? Okay, so say you've got this function dividing two numbers. Lots of languages, you'd return the answer, or if it blows up, there's an exception. Not Go. Go's like, well, I'll give you both. The result and an error value together. So you check that error, and if it's not nil, bam, you know something's up. Like a two-for-one deal, but for code? Elegant. I like it. And effective Go, it gets into how this changes everything about how you approach errors in Go. They're just another thing to deal with, no drama. Love that. Very practical. Now, they also mention defer. And I've got to be honest, that one sounds a bit mysterious. Break it down for me. Defer is like setting a reminder in your code. No matter what, success, failure, whatever, this function will run right before the current one finishes up. Like a built-in cleanup crew, making sure nothing's left behind. Exactly. Files to close, resources to release, whatever it is, defer, make sure it happens. And here's a fun bit. It's not tied to a block of code like in some languages. It's tied to the function. Opens up some cool possibilities. Huh, interesting. Go seems to be all about that power meets elegance vibe. Speaking of which, let's talk data structures. Arrays, slices, maps. The usual suspects, but I'm guessing Go has a twist. Oh, absolutely. Take arrays. Assign one to another in Go. You're not just pointing to the same thing. You're copying the whole shebang, the whole array. Which Effective Go points out can be good or bad memory-wise. Yeah, most languages, you're just referencing the same data. That's a big difference. Could prevent some nasty bugs, but also memory hog, potentially. Exactly. Trade-offs, trade-offs. And if you need that flexibility, Go's got your back with slices. Think dynamic arrays that grow as you need them. Super handy. Dynamic arrays, nice. But okay, Wikipedia throws us this curveball. Apparently, Go didn't even have generics for ages. What's the story there? Ah, yes, the great generics debate. It's a whole thing in Go's history. So generics, right? Write code once, use it with tons of data types, everyone's happy. Except in early Go, they just weren't there. Really? But developers love generics. Why leave them out? Go's creators, they had their reasons. Keep it simple, avoid the headaches other languages have. That was the goal. Effective Go even kind of hints at this, how they were intentionally trying to be different. But man, did it spark debate. People were not shy about wanting generics in Go. Sounds like they stuck to their guns for a while. So what changed? Well, they eventually came around after tons of discussion, trying things out. Finally, Go 1.18, boom, generics arrive. But the whole debate, it shows you something important about Go. This isn't a language afraid to shake things up, you know? Even if it means going against the grain. A language with convictions. And speaking of potentially controversial, even Go's famous concurrency, Wikipedia says it has its critics. It's true. Go makes concurrency, like, approachable. Goroutines, channels, it's elegant, it's powerful. But it ain't magic. You can still run into trouble, like data races, if you're not careful. Data races sounds messy. What are we talking about here? Imagine you've got multiple threads, those goroutines, all trying to access and change the same data at the same time. That's a data race, and it can lead to all sorts of unpredictable weirdness. Okay, so even with Go's safety features, you've still got to pay attention. Always. It's like, yeah, you've got a car with all the airbags and lane assist, but you're still driving. Go gives you the tools, but understanding how to use them safely, that's on you, the developer. Right, great power, great responsibility. And speaking of responsibility, Effective Go goes into how Go handles memory. Specifically, these functions, new and make. What's the deal there? They both seem to be about, like, creating things. Are they just two ways to do the same thing? Well, they're both involved in memory allocation, sure, but they each have their own job. See, new allocates the memory you need for a new value of some type, but it doesn't put anything in that memory. It just sets aside the space and sets it to its zero value. So, like, you get a brand new empty container. Exactly. Now, make, that's more specific. You use make when you're creating slices, maps, and channels. Those data structures we were talking about. Ah, right, right. So what makes make different, then? Make not only gives you that memory, but also sets it up properly, initializes it so the data structure's ready to use right away, because those structures often involve, like, more complex setup behind the scenes. So make is like, it not only hands you the keys, but also makes sure the fridge is stocked. Very thoughtful. Precisely. All the setup is done for you. You just start using it. I like it. Now, we've got to talk more about how Go handles errors. Effective Go, they really emphasize this. What's the philosophy there? Go's very direct when it comes to errors. Like, you deal with them head on, no hiding. It can be a little more code compared to some languages, but it makes things so much clearer. No sweeping things under the rug. I'm picking up what you're putting down. Exactly. You're forced to think, what could go wrong, and what do I do about it? And remember those multiple return values we talked about? Big part of how Go does errors right there. Right, right. You get your result, or you get an error. No surprises. But Effective Go also mentions these panic situations. Those sound a bit more, well, drastic. Yeah, panic is like Go's way of saying, okay, everything's on fire, we can't go on like this. Not your average oops, file not found error. More like, the system's melting down, kind of thing. So, hitting the big red button. Pretty much. Important thing is panic. Usually that means your program's done, but Go being Go, there's a way to maybe recover. This function called, wait for it, recover. Recover. So you're saying there's a chance to get things back on track even after a panic. It's like a last-ditch safety net. You can use defer, remember. Set up a function that runs if there's a panic. Log the error, clean things up, maybe even try to shut down gracefully. Okay, now panic is sounding slightly less terrifying. Good to have a backup plan. Switching gears a bit, Effective Go talks about how Go extends the way types work. Something about embedding. Not the usual inheritance thing, right? You're right. Embedding in Go is super cool. You basically get to borrow the behavior of another type without getting into this whole complicated inheritance hierarchy. So more of a mix-and-match approach. You got it. Let's say you have a struct and you want it to have all the same methods as, oh, I don't know, an I.O. reader. Handles reading data. Instead of inheriting from I.O. reader, you just embed it right into your struct. Boom. All those methods, now they belong to your struct too. Like giving your type superpowers. And the book even talks about how this can lead to some really elegant code with interfaces like I.O. reader and I.O. writer. Oh, for sure. You embed those interfaces, suddenly your type can read and write data. No problem. Very versatile. Very cool. Okay, let's get back to this whole concurrency thing. Seems like it's really at the heart of Go's design. You could say that. Go was built for concurrency. From the ground up, it's all about doing multiple things at once, smoothly and efficiently. And this is where our friends, the goroutines and channels, come in. You know it. Think of goroutines like lightweight threads. You

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
