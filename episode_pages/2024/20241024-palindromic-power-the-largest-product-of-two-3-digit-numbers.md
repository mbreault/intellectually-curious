# Palindromic Power: The Largest Product of Two 3-Digit Numbers

**Published:** October 24, 2024  
**Duration:** 4m 42s  
**Episode ID:** 17693164

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17693164-palindromic-power-the-largest-product-of-two-3-digit-numbers)**

## Description

A concise dive into Project Euler's palindrome problem. We explore why six-digit palindromes are divisible by 11, how to prune the search with number theory, and a Python approach to finding the largest palindrome from two 3-digit numbers. Weâ€™ll also cover a clean palindrome check in Python and ideas for scaling the method to larger factors.

## Transcript

Ever notice that some numbers read the same backward and forward? Uh, like 121. Yeah, exactly, like 121. Or 2002. Yeah, those are called palindromes. And it's also the largest one you can make by multiplying two-digit numbers. Right, 9 times 11 is 99. Yeah, but what if we up the ante? Like, uh, make the numbers bigger. Yeah, and try to find the biggest palindrome made from multiplying two three-digit numbers. Ooh, that sounds fun. Yeah, that's our challenge today as we take a deep dive into a classic coding problem from Project Euler. Project Euler is fascinating. Yeah. These problems aren't just about brute force calculation. They really push you to think about efficient solutions. Which is where number theory and clever algorithms come in handy. So it's not just about the code. Right. It's about the thinking behind the code. Exactly. And in this case, the key is understanding some interesting properties of palindromes. Okay. For example, did you know that any six-digit palindrome is always divisible by 11? Really? Yeah. I did not know that. It's true. How come? It's all about the structure. Let's take the palindrome 352253 as an example. Okay, 352253. Exactly. Got it. We can break it down like this. 3003 plus 550 plus 2020. Oh. See how each part has a mirrored pair of digits? This pattern lets us rewrite the number as 1001 times 3 plus 110 times 5 plus 110 times 2. Wow. And if you look closely, 1001, 110, and 110 are all divisible by 11. This divisibility rule is our secret weapon for quickly eliminating a ton of potential candidates. So we can rule out anything that's not divisible by 11. Exactly. Okay, that makes sense. Yeah. So how do we actually use that in our code, though? Well, imagine we're searching for our largest palindrome. Okay. It's like walking down a staircase where each step represents a product of two three-digit numbers instead of checking every single step. We can use this divisibility rule to take giant leaps, skipping over steps that couldn't possibly be palindromes. Oh, so we're not checking every single number. Okay. We're just checking the ones that could be palindromes. So we're starting with the largest possible products. Yes. And working our way down. Precisely. That's the optimization strategy. Okay. And when it comes to the actual implementation, Python is our tool of choice. I can see where loops would be handy for generating those products. Yes. Starting from 999 down to 100. That's right. But how do we actually check if a number is a palindrome in Python? There are a few ways. Okay. But a particularly elegant one uses the reversed function. Okay. Think of it like this. You convert the number into a string. Okay. You use reversed to flip it around and then compare the original string with the reversed one. Okay. If they match. Yeah. You've got yourself a palindrome. Gotcha. Easy. Oh, that's clever. Yeah. And we can store all the palindromes we find in a list, right? Yeah. That way we can easily keep track of them and find the largest one at the end. Makes sense. Python lists are perfect for this. Okay. They're like dynamic containers that can grow as we add more palindromes to them. And don't forget the importance of clear, well-commented code. Yeah, for sure. It's like leaving breadcrumbs for yourself or anyone else who might explore your solution later. Right. Or if you come back to it like six months later and you're like, what was I doing here? Exactly. This is reminding me of how important it is to choose the right tool for the job. Yes. Like Python lists wouldn't be as useful if we needed our data to be in a specific order. Right. That's a great point. Choosing the right data structure can make your code much more efficient. Oh, yeah. In this case, a list works well because we don't need our palindromes to be sorted in any particular order. Right. We just need a way to store them and easily compare them. Okay, cool. So we've gone from a simple sounding puzzle to leveraging number theory and then implementing a clever solution using Python. And what's really cool is that this approach can be adapted for other problems too. Oh, okay. For example, what if we wanted to find the largest palindromes made from the product of four digit numbers or five digit numbers? Yeah. The core logic remains the same. We just need to tweak our code slightly. That's an awesome thought to leave our listeners with. Right. It's like a whole new set of challenges just waiting to be tackled. Exactly. Give Project Euler a try. Yeah. So if you're up for it, Project Euler is an incredible playground for exploring the world of problem solving with Python. There's a whole universe of fascinating problems just waiting to be cracked open. Definitely. All right. Thanks for joining us for this deep dive. Of course. It was my pleasure. Until next time. See you later, Offer.

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
