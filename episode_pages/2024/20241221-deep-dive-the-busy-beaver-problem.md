# Deep Dive: The Busy Beaver Problem

**Published:** December 21, 2024  
**Duration:** 11m 20s  
**Episode ID:** 17692265

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17692265-deep-dive-the-busy-beaver-problem)**

## Description

Join us as we explore the Busy Beaver problem: how a tiny Turing machine with a fixed number of states can produce astonishing output or run forever, and why this problem sits at the edge of computability. Weâ€™ll unpack halting, uncomputability, and the limits of proof, plus intriguing connections to cellular automata and open mathematical conjectures.

## Transcript

Welcome to the Deep Dive. Today we're going to be looking into the Busy Beaver problem. Oh yeah, the Busy Beaver problem. It's a fascinating concept. It really is. And it's a problem in theoretical computer science. Right. Have you ever heard of a Turing machine that's been designed to run for as long as it possibly can or to produce as much output as possible? Yeah. Yeah, I'm familiar with that concept. That's essentially the Busy Beaver problem. It sounds simple. It does sound simple, but... It's really not. Yeah, it dives into some pretty fundamental questions about computability. Yeah. The limits of what we can know mathematically. Exactly. It really gets into the heart of what computation is. So okay, let's back up for a second and just kind of like unpack this a bit. Sure. So the Busy Beaver game, as it's often called, is all about finding a Turing machine with a certain number of states that does the most work before halting. Right. And we measure this work in two ways. Either by the number of ones it writes on its tape or by the number of steps it takes before halting. You got it. And you know what makes it so intriguing? What's that? Is that even with a small number of states, these machines, they can have really complex and unpredictable behavior. Yeah, I can imagine. It really challenges our intuition about simplicity versus complexity in terms of computation. So for our listeners who maybe aren't as familiar with Turing machines, can we just like really quickly recap what they are and how they work? Absolutely. So imagine you have like an infinitely long tape. Okay. And it's divided into cells and each cell can hold a symbol like a zero or a one. And the machine has a head that can read and write these symbols on the tape and it can move left or right. Gotcha. And it also has a set of internal states and a set of rules that govern its actions. So it's kind of like a very, very simple model of a computer program. Yeah, exactly. And the amazing thing is that Turing machines are theoretically capable of performing any computation that any other computer can do. Given enough time and memory, that's the key. So how do we actually find these Busy Beavers? Like, is there a formula or an algorithm that can tell us which machine will win for a certain number of states? That's where things get really, really interesting because to figure out the ultimate Busy Beaver, you'd basically have to simulate every possible Turing machine with that number of states. Right. But here's the thing. A lot of these machines, they might never halt. Oh, they could just keep running forever. Yeah. And that leads to the concept of uncomputability. Okay, uncomputability. Which basically means there's no general algorithm. Right. No set of instructions that you can use to calculate the Busy Beaver for any number of states. So it's impossible to figure out. It's deeply connected to the halting problem. Right, the halting problem. Which asks, given a program and its input, can you determine whether it will eventually stop or run forever? Yeah. And that has been proven to be undecidable. So if we can't actually compute the Busy Beaver for any number of states, how do researchers even approach this problem? Well, for small numbers of states, like one, two, three, or four, researchers have been able to analyze all the possible machines and figure out the winners. So they have to go through every single possibility. Do exhaustive search and clever proof techniques. That's going to be a ton of work. Yeah, but as the number of states gets bigger, the number of possible machines, it just explodes. Exponentially. Exponentially. I can imagine. So it gets really hard to find those champions. It sounds like we're dealing with a problem that quickly scales beyond our computational capabilities. Exactly. Even with relatively small numbers of states, we hit these limits of computability. You got it. But even though we can't find the exact Busy Beavers for really large numbers of states, the problem has really profound implications. Oh, really? Especially when we consider its connections to open questions in mathematics. That's what I think is so cool about the Busy Beaver problem. It's like this bridge between theoretical computer science and pure math in this really surprising way. Exactly. And in the next part of our deep dive, we can explore those connections a little bit more. Okay. We'll look at how hypothetical Busy Beavers could potentially be used to solve some of the most challenging conjectures in mathematics. Sounds good. I'm excited for that. Welcome back. So let's dive into how these Busy Beavers could actually be used to solve some of these unsolved mathematical problems. Yeah. This is the part I've been waiting for. It sounds like science fiction. It really does. But it's a pretty profound connection. So imagine you have a mathematical conjecture. Okay. Like Goldbach's conjecture. Goldbach's conjecture. Yeah. Have you heard of that one? Yeah. It's like every even number greater than two can be written as the sum of two prime. Exactly. And it's one of these really simple statements that has stumped mathematicians for centuries. For a long time. So imagine you could design a Turing machine. It would test this conjecture. Okay. So it would go through every even number and see if it could be expressed as the sum of two primes. Exactly. And if it finds an example where that's not true... A counterexample. Or a counterexample, the machine would just stop. Halt. But if the conjecture is true... It would just keep running forever. It would just keep running and running, testing every even number. So that makes sense. So how does the Busy Beaver fit into all of this? Okay. So here's the key. If we knew the maximum number of steps that any Turing machine with a given number of states could take before halting. So like if we knew that Busy Beaver function... Exactly. If we knew that function for that number of states, we could run our Goldbach testing machine for that many steps. Okay. And if it hasn't halted by then? It hasn't halted. We could be like, okay, Goldbach's conjecture must be true. Wow. Because if it was false, our machine would have found that counterexample. That's a really interesting thought. So theoretically, if you know the Busy Beaver for a large enough number of states... You could solve all these crazy conjectures in mathematics. That's right. That Busy Beaver function essentially gives us a way to bound the possible runtime of any Turing machine with a given number of states. So it's like a clock for how long a certain program could run. It's like a computational clock. Before you know that it's in an infinite loop. Exactly. But wait, didn't we say before that the Busy Beaver function is uncomputable? That's the big caveat. So we can't actually calculate it. Even for small numbers of states, the Busy Beaver function, it just grows ridiculously fast. Oh, wow. So the numbers get really big really fast. Astronomically large. I can imagine. Way beyond anything we can practically compute. So it sounds like this theoretical connection is really cool, but we just can't practically do it. We're limited by the scale of the problem. So the numbers are just too big. The numbers are way too big, but it really shows this deep connection between computation and proof. Yeah. And the limits of mathematical knowledge. It motivates people to find other ways to maybe approximate the Busy Beaver function. To get around that uncomputability problem. Exactly. So the Busy Beaver problem is kind of like this unattainable thing. Yeah. It's this idea that you can't quite reach. Right. But it pushes us to explore the boundaries of what's computable and what we can know. Exactly. And beyond the implications for mathematics, the Busy Beaver problem has also led to some interesting connections with other areas of computer science, like cellular automata. Oh, yeah. Cellular automata. Those are those systems with simple rules that can generate complex patterns. Exactly. Like you might see those really visually appealing grids of cells changing. So what's the connection between those and Busy Beavers? Well, it turns out the output of some of these Busy Beavers, especially those with higher numbers of states, actually look very similar to the evolution of certain cellular automata. Oh, wow. So these Turing machines trying to create as much output as possible are inadvertently creating these really complex patterns. It suggests there might be a deeper link between these really simple rules of Turing machines and the emergence of complexity in other systems. That's fascinating. Yeah. So it's a really exciting connection that a lot of researchers are looking into. That's awesome. So we've covered a lot of ground so far about how this Busy Beaver problem is related to other areas of computer science and mathematics. But I'm kind of curious now about some of the specific Busy Beavers that people have actually found. Can we talk about some of those? So let's talk about some of the actual Busy Beavers that researchers have found. You mentioned earlier that for smaller numbers of states, they've been able to find the winners. What can you tell us about these computational marvels? Well, for the simplest case, the one state Busy Beaver, it's really straightforward. It just writes a single one on the tape and then it halts. Okay, so not really a powerhouse there. Not very impressive. What about for two states? For two states, things get a little bit more interesting. The two state champion can write four ones on the tape before it halts. And it involves moving back and forth, changing states, even overwriting some of its own output. So even with just two states, it gets kind of complicated. Yeah, a little bit. What about the three state Busy Beaver? The three state Busy Beaver, that one's been proven to write six ones on

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
