# OEIS A000214

**Published:** May 05, 2025  
**Duration:** 9m 50s  
**Episode ID:** 17692986

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17692986-oeis-a000214)**

## Description

Learn about OEIS A000214

## Transcript

Welcome back to our deep dive series. Today we're continuing our journey through the OEIS, especially for you number theory students out there, looking at sequence A000214. Ah yes, an interesting one. It bridges logic, computation, and abstract algebra. Exactly. It counts, well, the number of essentially different types of Boolean functions. Which is fundamental. Boolean functions, they're just about true, false, 0 or 1 inputs and outputs. Susceptibly simple building blocks. But they underpin everything from, you know, basic computer circuits to complex cryptographic algorithms. So understanding their structure, their classification is really key. Right. And when we talk about Boolean functions of n variables, the sheer quantity is mind-boggling. It really is. The total number is 2 raised to the power of 2 to the n. So even for n4, just 4 inputs. You're looking at 2 to the 16 functions. What's that, over 65,000? Oh wait, my mistake, 2 to the 24 is 2 to 16, which is 65,536. Still a huge number. Ah, right, 65,536. And I think I misspoke earlier in my prep thinking of a slightly different context, maybe. But yeah, 65,536 distinct functions. Yes. And this is where sequence A000214 comes in and offers, well, a simplification. Okay. It tells us that even though there are tens of thousands of functions for n4, if we group them by certain symmetries, there are only 32 fundamentally different types. 32. That's a massive reduction. It highlights the power of classification, doesn't it? It really does. So the core of this deep dive then is understanding what fundamentally different means here. The OEIS description mentions equivalence classes under the action of the affine group AGN2. Right. That's the key phrase. We need to unpack that. Let's start with the functions themselves. n binary inputs, one binary output. Think of n switches, one light bulb. The function decides light on or off for every switch combination. Simple examples. If n plus 1, input x. You have four functions. Always output 0, always output 1. Output x. Or output the opposite of x, which is 1x. Okay. And for n2, inputs x and y. Then we jump to 222. 15 functions. That includes things like and and d or xor. Yeah. Familiar logic gates. So with so many functions, the big question is, when do we say two are basically the same, mathematically speaking? Even if, you know, their list of outputs, the truth table, looks different. Exactly. And the answer lies in symmetry. Can we transform one function into another by systematically messing with its inputs? Which brings us to this group action concept, and specifically the affine group AGN2. What's that about? So a group action is basically a formal way to talk about transformations. You have a set of objects, our Boolean functions, and a collection of transformations of the group. And the group action tells you how these transformations rearrange or change the objects. If one function can be turned into another using one of these transformations. They're considered equivalent in the same class. Precisely. They belong to the same equivalence class under that group action. Okay, so our group is AGN2, the affine group. What are affine transformations? Generally, an affine transformation over some field K is a mix. It's a linear transformation, things stretching, rotating, shearing, followed by a translation, just shifting the whole thing. Like in geometry. Exactly. And the invertible part is crucial. It means we can always undo the transformation, get back to where we started. And n2, what does the 2 signify? That tells us the field K is the binary field, GF2. Just two elements, 0 and 1. Ah, so all the arithmetic is modulo 2, 1 plus 1 over 0. Right, which makes things quite specific. Our space is the set of binary strings of length n. The linear part comes from invertible n by n matrices with 0s and 1s. That's the general linear group, GLN2. And the translation? Is just adding a fixed binary vector of length n after applying the linear map. So take an input vector, multiply by an invertible binary matrix, then add another binary vector. That's your transformed input. So AGN2 provides ways to systematically relabel or rearrange the inputs to a boolean function. Yes, in a structured, reversible way. It captures certain symmetries of the boolean hypercube, the space of 0, 1, n. Okay, so what does it mean for two boolean functions, say f and g, to be equivalent under AGN2? It means you can find an affine transformation t from AGN2 such that if you apply t to the inputs x before feeding them into f, the result is always the same as gx. So ftx equals gx for all possible input vectors x. I see. One function becomes the other just by doing this affine shuffle on its inputs. Exactly. So sequence A000214 counts these equivalence classes. It starts 3, 5, 10, 32, 382. Yes, those are the counts for n1, 2, 3, 4, 5 variables. Let's revisit n1. You said there were four functions total. Why three classes? Okay, the four functions are s00, x00, x, f1x, 1, feedx, x, and f0x, 1 plus x, and gf2. Right. Now, the constant functions 0 and 1 can't be transformed into anything else by changing the input. Applying t to x doesn't change the output if the output never depended on x. So s0 is one class, f1 is another. Makes sense. Two classes so far. Then consider fitx, x, and f0x, 1 plus x. Let's try the if transformation tx, x plus 1. It's invertible because ttx is x plus 1, plus 1, plus x, plus 0x. What is fit? It's fitx plus 1, which is just x plus 1. That's exactly s0x. Ah, so phi and f0 are equivalent under this t. Correct. They form a single equivalence class. So we have the class, the class f1, and the class phi, f0. That makes three classes in total for n1. That illustrates it perfectly. And the sequence grows quite fast after that, 5, 10, 32, 382, though obviously much, much slower than 2 to n. Much slower. It's still rapid growth, but manageable compared to the raw number of functions. The OEIS entry classifies it as non-nice, easy. Seems a bit tongue-in-cheek, maybe, given the complexity involved for higher n. Yeah, perhaps. Easy might be relative in the OEIS context. The underlying concepts are clear, but actually computing the terms for large n is very challenging. It involves some sophisticated combinatorial techniques, often using things like Burnside's lemma or Poyley enumeration theorem applied to the affine group. Okay, so why is this classification actually important? What do we gain by grouping functions this way? Well, primarily simplification. Instead of dealing with, say, 65,536 functions for n4, you can focus on the 32 representative types. How does that help practically? Think about circuit design. Maybe different functions within the same equivalence class have different costs to implement fewer gates, less power. Finding the simplest representative in a class is valuable. Ah, optimization. Or in cryptography. Many cryptographic properties of Boolean functions like nonlinearity, correlation immunity are often invariant under affine transformations. Meaning all functions in an equivalence class share the same security-relevant properties. Often, yes. So analyzing one representative tells you about the whole class. It helps in designing and analyzing S-boxes in block ciphers, for instance. It feels like a very fundamental mathematical approach. Understand something complex by understanding its symmetries. Absolutely. It's a recurring theme. We see it in geometry, in physics, and certainly in number theory, like when you study modular arithmetic, looking at properties that depend only on the remainder. So classifying by AGN2 is just one way to view these symmetries. The OEIS entry also links to A000585. That's the number of self-dual Boolean functions. Right. Self-duality is another kind of symmetry, related to complementing both inputs and outputs. The fact that these sequences are cross-referenced suggests interplay between different symmetry types. Interesting. And there are references mentioned. People like Leschner, Harrison, Freipertinger. They've dug deep into this. Oh, yes. Classifying Boolean functions under various groups, not just affine, but also permutation groups or the group generated by complementation of variables, is a rich field. Harrison's work was foundational. Freipertinger developed powerful tools using cycle indices of groups for enumeration problems like this. Cycle indices sounds complex. It's a tool from combinatorial enumeration that helps count distinct configurations under group actions. You don't need the details now, but it's the mathematical machinery behind calculating these sequence terms for larger n. So for number theory students listening, this dive into A000214 is a good example of how abstract algebra groups, fields, actions pops up and provides structure in unexpected places, like discrete functions crucial to computer science. Exactly that. It shows the connections. Finite fields, GF2, group theory, AGN2, combinatorics, counting classes, all applied to understand these fundamental objects of computation. Okay, so to wrap up, the key takeaway. A000

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
