# Python 3.14 Deep Dive for Engineers: Features, Performance, and Deprecations (Parts 1 & 2)

**Published:** February 14, 2025  
**Duration:** 13m 10s  
**Episode ID:** 17693424

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17693424-python-314-deep-dive-for-engineers-features-performance-and-deprecations-parts-1-&-2)**

## Description

A practical twoâ€‘part look for software engineers: whatâ€™s new in Python 3.14, how it affects your codeâ€”from lazy evaluation of annotations and clearer error messages to a tailâ€‘callâ€‘based interpreter and module updatesâ€”plus the deprecations youâ€™ll need to plan for.

## Transcript

Welcome to the deep dive, everybody. Today we're going to take a rapid look at Python 3.14. Yeah. But specifically what it means for software engineers. Absolutely. We're going to dig into everything, but really focus in on the things that are going to impact you writing code. Yeah, exactly. It's one thing to read the release notes. It's another thing to understand how it actually affects you. Totally. So where do we want to start? Well, I think the biggest thing is probably PTP649, which is deferred evaluation of annotations. And this is a really big deal for type hinting in Python. I've seen this come up on some of the Python forums and message boards and things. What makes it such a big deal? So previously type annotations were evaluated at runtime, which if you're not using them for type checking adds overhead. Right. So with deferred evaluation, they're stored in a special format and only processed if you actually are going to use them. So it's almost like lazy loading in a way. Yeah, exactly. Okay. So, I mean, I could see how that would improve performance, but like how much are we talking here? If you've got a large code base with extensive type hints, this could significantly reduce startup time and memory footprint. Oh, wow. Especially if you're not actually using a type checker. Yeah, that makes sense. At runtime. Okay. So we're talking about type hints. Does this finally mean that we can get rid of all of the string wrapped annotations? In many cases, yes. So 3.14 introduces a new module called AnnotationLib. Okay. And it's got some tools for like inspecting and resolving those forward references without needing the strings. Wow. Yeah. Okay. So annotations are getting faster, more flexible. But, you know, we all make mistakes. What about when things go wrong? Right. Are there any improvements to error messages? Yeah, absolutely. They've enhanced error messages in 3.14, particularly for things like unpacking assignments and even some of those like really tricky string formatting errors. Yeah, because like sometimes I get those and I just don't even know where to start. Right, right. And these improvements are really going to help you like pinpoint the root cause of what's going on much quicker. Can you give me a concrete example? Yeah. So let's say you're trying to unpack a tuple with three variables, but the tuple has four values. Okay. Previously, you might have gotten a value error, which isn't very helpful. Right, yeah, vague. But now it'll tell you like too many values to unpack. Okay. And it'll specify the expected and the actual number. Okay, that's much clearer. What about with strings? Oh, yeah. So imagine you have a multi-line string with a missing closing quote, right? So instead of just like pointing to the line where the error is, it might now suggest that the following line is intended to be part of that string. Hmm, that would be super helpful. Yeah. Okay, so you know better error messages. You know, as much as we don't want to admit it, debugging is a fact of life. Right. But now let's get to something that everybody loves, performance. I hear there's a new interpreter in Python 3.14. Yeah, this is where things get really exciting. It leverages tail calls for potential performance gains, especially with recursive functions. Oh, yeah, tail calls. I remember learning about that in like my compiler design class. How does that work again? So like when a function's last operation is a call to itself, instead of making a new stack frame for every call, the new interpreter will just reuse the existing frame. Interesting. Yeah, and that leads to significant speedups for like those really deeply recursive algorithms. Okay, so it's kind of like optimizing tail recursion. Does it apply to all recursive functions or are there limitations? So there are some limitations. It works best with like recent versions of Clang on x86-64 and ARC-64. Gotcha. Support for other compilers is coming, but right now it's a little limited. Okay, so I mean it's a performance boost and it sounds like it's still evolving. Yeah. But I mean a 9 to 15% speed improvement on average is nothing to sneeze at. Yeah, no, that's pretty substantial. What else should we know about? Well, apart from the big changes, there's also a ton of updates to like essential modules. Okay. Like ARB parse, Asensio, PyTypes, multiprocessing, and PathLib. All right, well let's dive into those a little bit. I mean ARB parse, that's like my go-to for command line parsing. What's new there? So one cool thing is how the help messages display the program name now. Okay. It'll accurately reflect how Python was instructed to find the main module, so it's more consistent. Okay. And there's a new option to enable argument suggestions. So if somebody misspells something, it'll try to like give them a little help. Oh, nice. That's a good UX improvement. Yeah. What about Asensio? Anything that'll make our asynchronous code even faster? Yeah, so Asensio is now using a double linked list for task management. And that's showing a 10% performance improvement on benchmarks. Wow, 10%, that's impressive. Yeah. How about MSync types? Anything new in the low-level world? A couple of things. The layout of bit fields and structures and unions has been like revised to better align with like the platform defaults. And you can now use several new functions for handling more complex types if your compiler and Libby library supports it. Okay, so maybe a little bit in the weeds for some listeners, but important if you're working with like C libraries and that sort of thing. Exactly. Okay, moving on. Multiprocessing, what's happening there? So one key focus is security. The fork server start method now uses like authenticated control soplets, which is more secure, reduces the risk of unauthorized processes spawning workers. Gotcha. And then also the proxy objects for lists and dictionaries, they've got new methods now. So they're a little more versatile. Nice. So it's getting more secure and more flexible. Yep. And last but not least, PathLib. Yeah, PathLib got some love too. Okay. There are new methods like copy, copy into, move and move into, which let you recursively copy or move files and directories. So it makes file management a lot easier. Okay, that's really useful. Yeah, and there's a new info attribute that caches file type information and stat results. So that can speed things up a bit. Cool. Well, it sounds like PathLib is getting a lot more powerful. Okay, so we've covered a lot of new stuff. Yeah. Additions, improvements. But as you know, with new features often come deprecations and removals. Right. And I'm very eager to dive into that, but maybe that's a good place to pause. Yeah, let's do a part two for that. Okay, so listeners, we will be back with part two where we talk about deprecations in Python 3.14. Welcome back. So we were about to get into those deprecations. Yeah, I'm ready to see what's going away, what we need to update in our code. Yeah, so let's start with ArcParts. Passing that undocumented prefixers keyword argument to a dargument group, officially deprecated now. Okay, so if we've been using that, we've got to refactor our code. Anything else in ArcParts? ArcParts.filetypeconverter, that's also being discouraged. Okay. So the recommendation now is to handle the resource management after parsing the arguments. Right, yeah, just keep it separate. Yeah, not during the parsing process itself. All right, good to know. What about the AST module? Any big changes there? Yeah, several AST classes that were deprecated since 3.8 have been removed. Okay. Like ISpites, AST Elipsis, AST NameConstant, AST Num, and AST Say. So if we've got any custom AST visitors that are handling those, we're going to need to update them. Right, so the recommendation now is to use AST Constant. Okay. And for those who are already using AST Constant, the N and S properties are gone. You have to access the EastConstant.value directly. Gotcha. So those are those little details that can really trip you up when you're upgrading. All right, what's next? Let's play Asensio. Asensio has seen some significant cleanup. Several functions and classes related to child watches, which were deprecated in 3.12, they're removed now. Okay, so what's the recommended way to handle child processes now in Asensio? Generally just use the standard subprocess module. Okay. It's a lot more robust, much more widely used. Yeah, makes sense. Also the Asensio policy system that's being deprecated. Okay. So functions like Getting a Loop Policy and classes like Abstract Event Loop Policy, those will be removed in 3.1.10. Okay, so we've got to start thinking about alternatives. Yeah, so for most cases, just using Asensio.run or Asensio.runner with custom loop factories should do it. Gotcha, so it seems like they're really trying to simplify Asensio. Make it more streamlined. Okay. What about built-in functions? Anything there? A few interesting ones. Okay. Using bitwise inversion on Boolean types, like tilde true or tilde false, that's deprecated. Yeah, that always felt a little weird to me. Right. So I guess just use not. Yeah, just use not x. Much clearer. Much more readable. Yep. What else? Also passing a complex number as the real or imaginary argument to the complex constructor, also deprecated. And what's the reasoning behind that? It's really about consistency and avoidant ambiguity. So passing the complex number as

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
