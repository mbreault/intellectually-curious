# Gleam Unpacked: A Friendly, Type-Safe Path to Scalable Software

**Published:** October 13, 2024  
**Duration:** 9m 27s  
**Episode ID:** 17692467

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17692467-gleam-unpacked-a-friendly-type-safe-path-to-scalable-software)**

## Description

Join us as we explore Gleam, the friendly, type-safe language designed for building scalable systems. We discuss how Gleam compiles to Erlang for high-concurrency backends and to JavaScript for frontend/lightweight apps, why its functional, modular approach boosts reliability, and what PQ42â€™s breakdown reveals about real-world usage. From hello world to case expressions, weâ€™ll connect core ideas like types, functions, and modularity with why this mattersâ€”even if youâ€™re not coding every dayâ€”showing how these design choices can improve software quality, collaboration, and tech decision-making.

## Transcript

So you're curious about Gleam, huh? This programming language is getting a lot of buzz, especially with how it approaches building really reliable software. And we're really digging into it today. We've got Gleam's official GitHub page right here, and a blog post from PQ42 that does a great job of breaking it down. And the timing couldn't be better. I mean, everyone wants software that's not just powerful but can scale up and adapt, right? The demand is huge. Absolutely. So let's jump right in. If you're trying to stay ahead of the curve in programming, now is the time to learn about Gleam. But first, what even is Gleam? Well, they describe it as a friendly and type-safe language. And that's for building what they call scalable systems. It sounds kind of jargony, but it really gets at how Gleam tries to find that balance, you know? Making it good for developers but also making sure it gets really robust results. Friendly. It almost sounds approachable. That's not a word you usually hear when you're talking about building these big, complex systems. You got it. That's actually a big part of what makes Gleam's whole design philosophy so interesting. When they say friendly, they mean they really focused on making it readable and easy to use. They want developers to actually enjoy coding with it. Which makes sense when you think about how many hours they spend doing it. So it's intuitive, which is great for the developer. But you mentioned type-safe. What's that all about, and why does it matter? Great question. Type-safe basically means that the language is designed to catch those little errors, those potential bugs, really early on in the development process. Think of it like an incredibly advanced spell checker for your code. It's making sure you're using the right kind of data in the right way. Okay, so fewer errors equals fewer bugs, which means more reliable software overall. Makes sense, especially for anything that's supposed to scale. You wouldn't want your app crashing if it suddenly got super popular, you know? Exactly. And this is where things get even more interesting with Gleam. See, to get that scalability, it actually compiles to Erlang. Now, Erlang is known for being able to handle a ton of activity, like LLQT, without any issues. Perfect for the kinds of demanding applications people are building these days. So Gleam taps into Erlang's power and stability for that. But the PQ42 blog mentioned something about it also being able to compile to JavaScript. Why is that a big deal? It's huge, E. Being able to compile to both Erlang and JavaScript, it makes Gleam incredibly versatile. Suddenly you're not limited to just one type of project. You can use it for back-end systems, the stuff that powers the entire online world, but also for those more user-facing applications, too. That's a powerful combo. You can tell they didn't want Gleam to be a one-trick pony. So we've got a friendly language that helps you write more reliable code with that whole type safety thing, and it can handle some serious scaling because of Erlang. What else makes Gleam so popular? What makes it stand out? A lot of it goes back to that whole friendly thing. And what PQ42 calls Gleam's functional programming paradigm. Now, functional programming, it might sound intimidating, but at its core, it's about writing code that's concise, it's modular, and most importantly, it's easier to really understand and work with. So instead of this big tangled mess of code, it's more about creating smaller, self-contained pieces that all work together. Exactly. And when you combine that modular approach with how clean and readable Gleam's syntax is, well, it becomes a much more enjoyable language to actually work with. And that's a big deal for developers who are staring at lines of code for hours on end. It's like trying to solve a puzzle compared to reading a straightforward set of instructions. Exactly. And that kind of clarity is so important, especially with software development where everything's getting more and more complex. And speaking of clarity, let's actually see what Gleam looks like in action. The PQ42 blog has some good examples. Perfect. I always love seeing how things actually work in practice. Well, they start with the classic, right? The hello world program, like a rite of passage for any programming language. You know, the one that just outputs the phrase, hello world. It's like a really basic intro to how the language's syntax works. Exactly. PQ42 points out how straightforward it is in Gleam. Basically, you're just giving the computer a clear instruction, no fuss, superhuman readable. So past the hello world stage, what other fundamental stuff does PQ42 cover about Gleam? They get into variables and types. Those are the basic building blocks of, well, pretty much any programming language. Variables, they're like containers for your data. And then types tell you what kind of data you can put in those containers. So it's all about making sure the data is organized, that everything's got its place and it's used in the right way. Precisely. PQ42 gives some examples of the basic types you'd see in Gleam. Like string is for text. Int is for whole numbers. Bool is for true or false values. It's all about being crystal clear about what's what right from the start. This whole type system sounds like it's a big part of why Gleam is so reliable. It makes sure the data is always used in a consistent and predictable way. But how does it handle actually doing stuff with the data, like calculations and all that? Good question. PQ42 actually touches on how Gleam handles those basic math operations. You can do addition, subtraction, multiplication, division, the whole nine yards, all within Gleam's syntax. So basic calculations are definitely on the table. Are we ready to start building crazy complex algorithms in Gleam yet? Hold your horses. Before we get to the super complex stuff, we've got to talk about functions. PQ42 gives a good example with a simple add function. It demonstrates how Gleam deals with these self-contained chunks of code. Right, functions. Those modular components that take some input, do something specific, and then spit out an output. It sounds like they're a big part of how Gleam keeps code organized, which is pretty important. Absolutely. Functions are essential for writing code that's clean, reusable, and not a nightmare to maintain, especially as things get more complex. And PQ42 does a great job of explaining it in a way that makes sense, even if you're not a coding whiz. So we've got the hello world down, learned about variables and types, touched on how it handles math, and even gotten a taste of functions. Gleam seems surprisingly capable for a language that's supposed to be so friendly. See, that's the beauty of it. It manages to be simple and approachable, but also really powerful. But the real question is, how does any of this matter to someone who's not coding every day? Why should we care about Gleam in a world that's just getting more and more driven by software? That's the big question, right? Like, if you're not going to go out and become a Gleam developer, why should you care about any of this? It's true. Most of us aren't writing code every day. But here's the thing. Even just having a little bit of knowledge about this stuff, about how programming languages work, it's becoming more and more useful, especially in a world that's just dominated by technology. You know what I mean? It's kind of like having a cheat sheet for understanding the technology that's all around us, shaping how we live and everything. Exactly. And in the case of Gleam specifically, it's about noticing this trend, this move towards languages that are all about clarity. Reliability. Code that you can actually maintain. And those principles, they're useful way beyond just software development. Okay, I see what you're saying. But how does that actually play out? Can you give me some real-world examples of how those ideas would be useful for someone who's not like a programmer? For sure. Let's take type safety, for example. Imagine you're working on a project, any project really, where it's super important for the data to be accurate, right? Knowing about type safety can actually help you design things, better systems, processes, even just spreadsheets. You can minimize errors and make sure everything's consistent. So it's like thinking ahead, planning for problems before they even pop up. Exactly. Being proactive. And that is so valuable no matter what you do. Or think about modularity, right? The whole thing we were talking about before, breaking down big, complex tasks into smaller chunks. That's huge for project management, for teamwork, even just for communicating clearly. It reminds me of that idea of chunking information to learn it better. Just breaking things up into manageable pieces. Gleam's just doing that with code, basically. Yeah, that's a great way to put it. And just by understanding these concepts, even if it's just the basics, it helps you talk to the tech people, make smarter decisions about technology in general, and just feel more confident navigating the world, which, let's face it, is pretty tech-dependent these days. It's about closing that gap, right? Between the people building the tech and the people actually using it every day. 100%. And hey, you never know. You might even get inspired to dive deeper into Gleam yourself. That PQ42 blog post is honestly a great place to start, especially the part about case expressions. They're crazy powerful for handling different possibilities in your code. You've definitely got me curious. But before we wrap up, what about that provocative thought you mentioned at the beginning? Any last thoughts after really diving into Gleam? Well, think about it. Gleam wants to make it easier for people to build these complex systems, right? So what if, down the line, creating really sophisticated software isn't just for

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
