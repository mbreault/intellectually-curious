# Microcode Deep Dive: The Hidden Layer Between Software and Silicon

**Published:** April 01, 2025  
**Duration:** 15m 29s  
**Episode ID:** 17692713

ðŸŽ§ **[Listen to this episode](https://intellectuallycurious.buzzsprout.com/2529712/episodes/17692713-microcode-deep-dive-the-hidden-layer-between-software-and-silicon)**

## Description

We pull back the curtain on microcodeâ€”the tiny, onâ€‘chip layer that translates machine code into the sequence of hardware steps your CPU executes. Learn what microcode is, why it exists (flexibility, compatibility, and patching bugs), how itâ€™s stored (ROM vs writable control stores), and the horizontal vs vertical microcode debate, with approachable analogies and realâ€‘world implications for performance and security.

## Transcript

Welcome back to the deep dive, everybody. Today in the science corner, we're going really deep down to the silicon. We're going to be talking about microcode in processor design. Oh, this is going to be fun. It is, right? This is the stuff that makes like, you know, for folks who love to understand how things actually work. At the lowest level. This is it. The foundation. This is the foundation of how a computer executes instructions. Right. How the ones and zeros actually get turned into actions. Yeah. And we're going to try to do it in a way that is, you know, again, approachable, fun. Absolutely. We're assuming our listeners are smart people. Yes, we are. And we don't have to, you know, rehash all the basics. But microcode. Right. So maybe we should just jump right into it. What is microcode? I mean, where does it fit in the whole scheme of like when I hit the letter A on my keyboard? Right. Or, you know, open an app or whatever. Where is microcode? So, you know, like you said, we're going deep. We're going down to the silicon. Yeah. You know, your CPU, the central processing unit. That's the brain of your computer. Yeah. Microcode lives, you know, essentially between the CPU hardware itself, the transistors and the machine code. OK. That programmers write. So it's this intermediary layer. OK. That translates those high level instructions. Oh, so it is a translation layer. It is a translation layer. OK. Because, you know, the hardware, you hit the A key. Right. The hardware doesn't know what that means. No, it doesn't speak English. Yeah. Not at all. So the machine code has to be translated into a series of very, very basic steps. So it takes like a complex instruction and it breaks it down into. Exactly. 11 instructions. 11 instructions. OK. And those are the microcode. Got it. And it has to do this because the circuits, the transistors in the CPU. Right. They can only do very simple things. Right. Add, subtract, move data. Got it. Got it. Microcode orchestrates all of that. I've heard the player piano analogy. Right. Is that a good analogy? It's not bad. I mean, you know, think about it. You've got the paper roll. Right. With the holes punched in it. Yes. That's kind of like the microcode. Right. And those holes tell the hammers. Right. Which strings to hit. That's the hardware. I like that. That works for me. Right. So the music is the result. And that's the program running. OK. So the microcode is telling the hardware what to do. Exactly. At a very granular level. Very granular level. Step by step. OK. And so where does this microcode live? Like physically, where is it? Right. So it's not in your RAM. You know, the main memory. OK. It's actually on the CPU chip itself. OK. In a special, very fast memory. Like built into the CPU. Built in. Yeah. Because it needs to be accessed really, really quickly. Got it. Every time an instruction is executed. OK. That makes sense. So you've got this extra layer, right? I mean, you've got the machine code. Right. And then you've got this microcode. Right. Why, like why bother? Why not just have the machine code directly talk to the hardware? OK. So there's a few reasons. One is historical. OK. You know, in the very, very early days of computers, CPUs were hardwired. OK. Meaning the control logic was basically fixed circuits. Oh, wow. And for very simple instructions, that was fine. It was fast. OK. But as instructions got more complex, as computers evolved, this hardwiring became a nightmare. Yeah. I mean, imagine trying to rewire a CPU every time you wanted to add a new instruction. Right. Yeah. So microcode came along as a way to make things more flexible. OK. So it's like software for the hardware. Kind of, yeah. It's a way to program the hardware. OK. And if you need to change something, you just change the microcode. You don't have to rewire everything. Exactly. Yeah. Much, much easier. OK. So flexibility. Flexibility. Got it. That's one big reason. And you mentioned also the complexity of instructions. Right. So, you know, a single machine code instruction. Yeah. Could actually involve dozens or even hundreds of tiny little steps. Right. At the hardware level. And microcode handles all of that. It breaks it down. Breaks it down. OK. It's like a recipe. OK. You know, you want to bake a cake. Right. You don't just say bake cake. Right. Yeah. No. There's a lot of steps. You need to mix the ingredients, preheat the oven. Yeah. Microcode is like the detailed instructions. Got it. OK. For the CPU. So it's the recipe for the cake. Exactly. OK. So flexibility, complexity. Right. What else? Why microcode? OK. So this is a big one, especially back in the day. OK. Compatibility. OK. So imagine you've got a family of computers. Right. Different models. Right. Some are cheaper. Some are more powerful. Sure. But they all need to run the same software. Right. You don't want to rewrite your software for every computer you buy. Exactly. So how do you do that? Microcode. Oh. You can have a simpler, cheaper CPU. Right. That uses microcode to emulate a more powerful CPU. Oh, so it's like faking it. It's kind of like faking it. OK. OK. But the software doesn't know the difference. That's amazing. So you get compatibility across the whole product line. So that was a huge selling point, I imagine. Oh, yeah. Especially for companies like IBM back in the day. Right. Right. Their System 360, all those different models. Right. Same instruction set, thanks to microcode. So they didn't have to rewrite software for every model. Exactly. Huge advantage. OK. So flexibility, complexity, compatibility. Right. I'm sure there's more. Oh, yeah. What if you find a bug in the CPU? Oh, right. Yeah. Like after it's already been manufactured. After it's shipped. Yeah. You don't want to have to recall all those chips. Right. Oh, that's a nightmare. It's a disaster. So often you can fix these bugs with a microcode update. Like a software patch. Exactly. Just like a software patch. So you're patching the hardware with software. Pretty much, yeah. That's amazing. It's a lifesaver. And it's also how they address security vulnerabilities. Oh, right. Because if there's a security flaw at the hardware level. That's a big problem. Yeah. So microcode updates can fix those, too. Wow. So microcode is like a secret weapon. It's a powerful tool. Yeah. In the hands of the processor designers. OK. So we've talked about why microcode is important. Right. But how does it actually work? Like how is it stored? OK. So traditionally, microcode was stored in ROM. ROM. Read-only memory. Right. And sometimes in programmable logic arrays, PLAs. OK. These are basically non-volatile memory chips. Meaning? Meaning they retain their contents even when the power is off. Oh, OK. And they're usually fixed at the factory. OK. So once the chip is made, the microcode is set. Got it. But you said traditionally. Right. Because nowadays, many processors use a writable control store. OK. Writable. So you can change it. You can change it. OK. This means the microcode is stored in something like SRAM. OK. Or even flash memory. Oh, OK. And it's loaded when the CPU boots up. Oh, I see. So this allows for updates, like we talked about. Right. The microcode updates. Exactly. OK. So the microcode is stored in this special memory. Right. And it's made up of micro-instructions. Yes. So what do these micro-instructions look like? Well, there are two main types, horizontal and vertical. OK. Horizontal microcode, the instructions are wider. Wider, meaning? Meaning they have more bits. OK. Sometimes 50, sometimes over 100. Wow. And each bit or group of bits directly controls a specific part of the CPU. So it's very direct. Very direct, very parallel. OK. So a single horizontal micro-instruction might say, move data from register A to the ALU and add the contents of register B. And all that's happening at the same time? Potentially, yeah. It depends on the design. Wow. And it also might specify where to store the result. OK. Update status flags, all sorts of things. So it's like a very detailed, very specific set of instructions. Exactly. OK. And then vertical microcode. Vertical microcode is more encoded. Encoded. Meaning it uses fewer bits. OK. So the instructions are shorter. Right. But this means they need to be decoded. Decoded. Yeah. The CPU needs to figure out what the bits actually mean. Oh, I see. So it's like a shorthand. Kind of, yeah. It's a more compact way to represent the instructions. OK. But it adds a little bit of overhead. Because of the decoding. Right. OK. So horizontal is faster, but takes up more space. Generally, yeah. And vertical is slower, but more compact. Right. Got it. And some processors use a combination of both. Oh, OK. Depends on the

---
*This episode was generated from the Intellectually Curious Podcast. For more episodes, visit our [main site](https://intellectuallycurious.buzzsprout.com).*
